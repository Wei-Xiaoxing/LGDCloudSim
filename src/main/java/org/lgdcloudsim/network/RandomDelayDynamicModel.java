package org.lgdcloudsim.network;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

/**
 * RandomDelayDynamicModel is an implementation of the {@link DelayDynamicModel} interface.
 * It is a simple dynamic delay model that adds a random delay to the static delay.
 * The random delay is generated by a Gaussian distribution with a mean of 0 and a standard deviation of 4.
 * It makes the dynamic delay between the same location at the same time the same through a hash function.
 *
 * @author Anonymous
 * @since LGDCloudSim 1.0
 */
public class RandomDelayDynamicModel implements DelayDynamicModel {
    @Override
    public double getDynamicDelay(int srcId, int dstId, double delay, double time) {
        // Ensure that the dynamic delay of the same two region at the same time is the same
        long seed = hashMap(srcId, dstId, time);
        Random random = new Random(seed);
        return Math.max(delay + random.nextGaussian() * 4, 0);
    }

    /**
     * Hash the source id, destination id and time to a long value.
     *
     * @param srcId the source id.
     * @param dstId the destination id.
     * @param time  the time.
     * @return the hashed long value.
     */
    private long hashMap(int srcId, int dstId, double time) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");

            // Convert parameters to byte arrays
            byte[] srcIdBytes = ByteBuffer.allocate(4).putInt(srcId).array();
            byte[] dstIdBytes = ByteBuffer.allocate(4).putInt(dstId).array();
            byte[] timeBytes = ByteBuffer.allocate(8).putDouble(time).array();

            // Combine byte arrays
            byte[] combinedBytes = new byte[srcIdBytes.length + dstIdBytes.length + timeBytes.length];
            System.arraycopy(srcIdBytes, 0, combinedBytes, 0, srcIdBytes.length);
            System.arraycopy(dstIdBytes, 0, combinedBytes, srcIdBytes.length, dstIdBytes.length);
            System.arraycopy(timeBytes, 0, combinedBytes, srcIdBytes.length + dstIdBytes.length, timeBytes.length);

            // Calculate the hash value
            byte[] hashBytes = digest.digest(combinedBytes);

            // Convert byte array to long type
            long hashedLong = ByteBuffer.wrap(hashBytes).getLong();

            return hashedLong;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        return 0;
    }
}
